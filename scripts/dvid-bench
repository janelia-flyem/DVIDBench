#!/usr/bin/env python

import argparse
import os
import sys
import dvidbench
import json
import time
import requests
import tempfile
import shlex
import signal
import re
from subprocess import call, Popen, PIPE
from dvidbench import benchmark
from pkg_resources import resource_filename

__log_file__ = './dvidbench.log'

def get_repo_info (config):
    server_info_url = "http://%s/api/repos/info" % config['host']
    try:
        response = requests.get(server_info_url)
    except requests.exceptions.ConnectionError:
        sys.stderr.write("There was a problem contacting the server at %s. Is it available?\n" % config['host'])
        sys.exit(1)

    if response.status_code != 200:
        sys.stderr.write("There was a problem contacting the server at %s\n" % config['host'])
        sys.exit(1)
    return response.json()

def load_settings (args):
    sys.stderr.write("looking for settings in %s\n" % args['config'])
    try:
        config_json = open(args['config'])
        config = json.load(config_json)
    except IOError:
        sys.stderr.write("unable to find the config file: %s\n" % args['config'])
        sys.exit(1)
    except ValueError:
        sys.stderr.write("There was a problem reading the config. Is it valid JSON?\n")
        sys.exit(1)

    # merge the command line args with the ones loaded from the config file.
    # command line always wins.
    config.update(args)

    return config

def repo_selection(repos):
    repo_list = []
    selected_repo = None
    # strip off all the null repositories
    for repokey in repos:
        if repos[repokey]:
            repo = repos[repokey]
            repo_list.append({'uuid': repokey, 'desc': repo['Description']})

    # print out the list
    for i,val in enumerate(repo_list):
        print "%s\t%s\t%s" % (i + 1, val['uuid'], val['desc'])

    while not selected_repo:
        #gather the input
        choice = raw_input("Please select a repo to test against: [1] ")

        if not choice:
            choice = 1

        try:
            choice = int(choice)
        except ValueError:
            print "invalid choice, please try again."
            continue

        try:
            selected_repo = repo_list[choice - 1]
            print "you chose %s - %s" % (choice, selected_repo['uuid'])
        except IndexError:
            print "invalid choice, please try again."
            continue

    return selected_repo['uuid']

# http://stackoverflow.com/questions/377017/test-if-executable-exists-in-python
def which(program):
    import os
    def is_exe(fpath):
        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)

    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            path = path.strip('"')
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return exe_file

    return None

def check_siege_installed(config):
    siege_path = ''
    if 'siege_path' in config:
        siege_path = which(config['siege_path'])
    else:
        print "searching for siege application..."
        siege_path = which('siege')

    if not siege_path:
        sys.stderr.write('siege does not appear to be installed in your PATH. Please install it or add the full path to your configuration\n')
        sys.exit(1)

    print "using siege found at %s" % siege_path
    config['siege_path'] = siege_path
    return

def create_temporary_urls_file (config):
    #open temporary file for writing
    urls = tempfile.NamedTemporaryFile()
    for url in config['urls']:
        urls.write(url + "\n")

    urls.flush()
    return urls


def verify_or_create_log_dir(config):
    if not os.path.isdir(config['logs']):
        os.makedirs(config['logs'])
    return

def create_log_file(config):
    if 'results' in config:
        config['log_prefix'] = config.get('results')
    else:
        config['log_prefix'] = time.strftime("%Y%m%d-%H%M%S-") + str(os.getpid())

    config['log_file'] = config.get('log_prefix') + '.log'

    global __log_file__
    __log_file__ = os.path.join(config['logs'], config['log_file'])
    return


def execute_siege(config, concurrent, urls_file):
    siege_config = resource_filename(__name__, '../siege.dat')
    cmd = '%s -R%s -b -d1 -t5s -c%s -f%s -l%s -m%s' % (config['siege_path'], siege_config, concurrent, urls_file.name, __log_file__, concurrent)
    if 'debug' in config and config['debug']:
        print cmd
    args = shlex.split(cmd)
    proc = Popen(args, stdout=PIPE, stderr=PIPE)
    out, err = proc.communicate()
    exitcode = proc.returncode
    if 'debug' in config and config['debug']:
        print out # displays individual url timings
        print err # displays runtime summaries

    # save the results to disk / sqlite database?
    stdout_log = open(os.path.join(config['logs'], config['log_prefix']) + '-' + str(concurrent) + '-stdout.log' ,'a')
    stdout_log.write(out)

    stderr_log = open(os.path.join(config['logs'], config['log_prefix']) + '-' + str(concurrent) + '-stderr.log' ,'a')
    stderr_log.write(err)

    return

def display_results(config):

    log_file = config.get('log_file')

    # open the log file and dump it to the terminal
    with open(log_file) as summary:
        for line in summary:
            if re.search('\*{4}', line):
                print line

    for i in range(min_connections(config), max_connections(config), config.get('increments', 50)):
        if i < 1:
            i = 1
        print "stats for {0} connections".format(i)


        log_path = os.path.join(config['logs'], config['log_prefix']) + '-' + str(i) + '-stdout.log'
        print "looking at logs {0}".format(log_path)

    return


# this installs a signal handler to trap CTRL-C and exit the program
# gracefully.
def signal_handler(signal, frame):
    # do cleanup here.
    logs = open(__log_file__, 'a')
    logs.write("Program terminated by user")
    # finally quit
    sys.stderr.write("Program terminated by user.\n")
    sys.exit(0)
signal.signal(signal.SIGINT,signal_handler)

def min_connections(config):
    min = config.get('min_connections',0)
    # start the range at 0 otherwise we get 1, 21, 41, 61 instead of 1, 20, 40, 60
    if min <= 1 and config.get('increments', 50) > 1:
        min = 0
    return min

def max_connections(config):
    max = config.get('max_connections',500) + 1
    return max

def main ():
    parser = argparse.ArgumentParser(description='Benchmark a DVID server')
    parser.add_argument('-v', '--version', action="version", version=dvidbench.__version__ )
    parser.add_argument('config', help='location of the configuration file', nargs='?', default='.dvidbenchrc')
    parser.add_argument('-d', '--debug',  help='print extra debugging information', action='store_true')
    parser.add_argument('-r', '--results',  help='parse results in supplied log file', action='store')
    cl_args = vars(parser.parse_args())
    # okay, we have the command line arguments

    # look to see if the settings file exists.
    config = load_settings(cl_args);

    if 'results' in config:
        create_log_file(config)

    else:
        # contact the configured server and make sure it is alive
        repo_info = get_repo_info(config)

        # print out repo list and ask which one to use if one isn't specified in settings
        if not 'repo' in config:
            config['repo'] = repo_selection(repo_info)

        # TODO: create a repo and upload tiles if required

        check_siege_installed(config)

        urls_file = create_temporary_urls_file(config)

        verify_or_create_log_dir(config)

        create_log_file(config)

        print "run the benchmarking code now: " + dvidbench.__version__

        # go through the users in incremental steps from min to max as configured by
        # the user.


        for i in range(min_connections(config), max_connections(config), config.get('increments', 50)):
            # always have at least one connection.
            concurrent = i
            if concurrent < 1:
                concurrent = 1
            print "checking {0} concurrent connections".format(concurrent)
            execute_siege(config, concurrent, urls_file)
            time.sleep(5)

    # parse the results and provide a summary output.
    display_results(config)
    # if really fancy, we can generate an html page with graphs.

if __name__ == "__main__":
    main()
