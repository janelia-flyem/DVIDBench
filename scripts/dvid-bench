#!/usr/bin/env python

import argparse
import os
import sys
import dvidbench
import time
import shlex
import signal
import dvidbench
from subprocess import call, Popen, PIPE
from dvidbench.benchmark import Benchmark

__log_file__ = './dvidbench.log'







def execute_siege(config, concurrent, urls_file):
    siege_config = dvidbench.__siegedat__
    cmd = '{program} -R{config} -d1 -t{duration}s -c{concurrent} -f{urls} -l{log} -m{message}'.format(
        program=config['siege_path'],
        config=siege_config,
        duration= config.get('duration', 5),
        concurrent=concurrent,
        urls=urls_file.name,
        log= __log_file__,
        message=concurrent
    )
    if 'debug' in config and config['debug']:
        print cmd
    args = shlex.split(cmd)
    proc = Popen(args, stdout=PIPE, stderr=PIPE)
    out, err = proc.communicate()
    exitcode = proc.returncode
    if 'debug' in config and config['debug']:
        print out # displays individual url timings
        print err # displays runtime summaries

    # save the results to disk / sqlite database?
    stdout_log = open(os.path.join(config['logs'], config['log_prefix']) + '-' + str(concurrent) + '-stdout.log' ,'a')
    stdout_log.write(out)

    stderr_log = open(os.path.join(config['logs'], config['log_prefix']) + '-' + str(concurrent) + '-stderr.log' ,'a')
    stderr_log.write(err)

    return


# this installs a signal handler to trap CTRL-C and exit the program
# gracefully.
def signal_handler(signal, frame):
    # do cleanup here.
    logs = open(__log_file__, 'a')
    logs.write("Program terminated by user")
    # finally quit
    sys.stderr.write("Program terminated by user.\n")
    sys.exit(0)
signal.signal(signal.SIGINT,signal_handler)


def main ():
    parser = argparse.ArgumentParser(description='Benchmark a DVID server')
    parser.add_argument('-v', '--version', action="version", version=dvidbench.__version__ )
    parser.add_argument('config', help='location of the configuration file', nargs='?', default=os.path.expanduser('~/.dvidbenchrc'))
    parser.add_argument('-d', '--debug',  help='print extra debugging information', action='store_true')
    parser.add_argument('-r', '--results',  help='parse results in supplied log file', action='store')
    cl_args = vars(parser.parse_args())
    # okay, we have the command line arguments

    bench = Benchmark(args=cl_args)

    if bench.config.get('results'):
        bench.create_log_file()

    else:
        # contact the configured server and make sure it is alive
        repo_info = bench.get_repo_info()

        # print out repo list and ask which one to use if one isn't specified in settings
        #if not 'repo' in config:
        #    config['repo'] = repo_selection(repo_info)

        bench.check_siege_installed()

        urls_file = bench.create_temporary_urls_file()

        bench.verify_or_create_log_dir()

        global __log_file__
        __log_file__ = bench.create_log_file()

        print "started dvidbench v{}".format(dvidbench.__version__)

        # go through the users in incremental steps from min to max as configured by
        # the user.


        for i in range(bench.min_connections(), bench.max_connections(), bench.config.get('increments', 50)):
            # always have at least one connection.
            concurrent = i
            if concurrent < 1:
                concurrent = 1
            print "checking {0} concurrent connections".format(concurrent)
            execute_siege(bench.config, concurrent, urls_file)
            time.sleep(5)

    # parse the results and provide a summary output.
    bench.display_results()
    # if really fancy, we can generate an html page with graphs.


def repo_selection(repos):
    repo_list = []
    selected_repo = None
    # strip off all the null repositories
    for repokey in repos:
        if repos[repokey]:
            repo = repos[repokey]
            repo_list.append({'uuid': repokey, 'desc': repo['Description']})

    # print out the list
    for i,val in enumerate(repo_list):
        print "%s\t%s\t%s" % (i + 1, val['uuid'], val['desc'])

    while not selected_repo:
        #gather the input
        choice = raw_input("Please select a repo to test against: [1] ")

        if not choice:
            choice = 1

        try:
            choice = int(choice)
        except ValueError:
            print "invalid choice, please try again."
            continue

        try:
            selected_repo = repo_list[choice - 1]
            print "you chose %s - %s" % (choice, selected_repo['uuid'])
        except IndexError:
            print "invalid choice, please try again."
            continue

    return selected_repo['uuid']


if __name__ == "__main__":
    main()
